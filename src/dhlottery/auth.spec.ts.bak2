/**
 * DHLottery Authentication Tests
 *
 * Trace:
 *   spec_id: SPEC-AUTH-001
 *   task_id: TASK-002, TASK-011
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import { login } from "./auth";
import { createHttpClient } from "../client/http";
import { AuthenticationError } from "../utils/errors";
import type { AuthEnv, HttpResponse } from "../types";

describe("DHLottery Authentication", () => {
  let mockHttpClient: ReturnType<typeof createHttpClient>;
  let mockEnv: AuthEnv;

  beforeEach(() => {
    // Create mock HTTP client
    mockHttpClient = {
      cookies: {},
      fetch: vi.fn(),
      getCookieHeader: vi.fn(),
      clearCookies: vi.fn(),
    } as unknown as ReturnType<typeof createHttpClient>;

    // Create mock environment with secrets
    mockEnv = {
      USER_ID: "testuser",
      PASSWORD: "testpass123",
    };
  });

  /**
   * Helper function to create mock responses
   * Returns session init response and login response
   */
  const createMockResponses = (loginResult: { resultCode: string; resultMsg?: string }) => {
    const sessionInitResponse = {
      status: 200,
      statusText: "OK",
      headers: new Headers(),
      text: async () => "<!DOCTYPE html>...",
      json: async () => ({}),
    } as unknown as HttpResponse;

    // DHLottery returns HTML on success, JSON on failure
    const isSuccess = loginResult.resultCode === "SUCCESS";
    const loginResponse = {
      status: 200,
      statusText: "OK",
      headers: new Headers({
        'content-type': isSuccess ? 'text/html;charset=EUC-KR' : 'application/json',
      }),
      text: async () => isSuccess
        ? '<script>var returnUrl = "https://dhlottery.co.kr/common.do?method=main";\nfunction goNextPage(){ location.href=returnUrl; }</script>'
        : JSON.stringify({ result: loginResult }),
      json: async () => ({ result: loginResult }),
    } as unknown as HttpResponse;

    return { sessionInitResponse, loginResponse };
  };

  /**
   * TEST-AUTH-001: Should authenticate with valid credentials
   *
   * Criteria:
   * - POST request to /userSsl.do?method=login succeeds
   * - Response indicates successful login
   * - Session cookies are updated
   * - User is considered authenticated
   */
  describe("TEST-AUTH-001: Authenticate with valid credentials", () => {
    it("should successfully authenticate with valid credentials", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
        resultMsg: "로그인 성공",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - should be called 3 times (session init + login + redirect)
      expect(mockHttpClient.fetch).toHaveBeenCalledTimes(3);

      // Verify first call is session init
      const sessionCall = vi.mocked(mockHttpClient.fetch).mock.calls[0];
      expect(sessionCall[0]).toContain("/common.do?method=main");
      // Note: method is explicitly set to 'GET' in initSession

      // Verify second call is login
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      expect(loginCall[0]).toContain("/userSsl.do?method=login");
      expect(loginCall[1]?.method).toBe("POST");
    });

    it("should handle successful login with cookies", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - should not throw
      expect(mockHttpClient.fetch).toHaveBeenCalledTimes(3);
    });

    it("should parse successful login response", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act & Assert - should not throw
      await expect(login(mockHttpClient, mockEnv)).resolves.not.toThrow();
    });
  });

  /**
   * TEST-AUTH-002: Should reject invalid credentials
   *
   * Criteria:
   * - Login fails with invalid credentials
   * - AuthenticationError is thrown
   * - Error message describes the failure
   */
  describe("TEST-AUTH-002: Reject invalid credentials", () => {
    it("should throw AuthenticationError on invalid credentials", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "FAIL",
        resultMsg: "아이디 또는 비밀번호가 일치하지 않습니다",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).rejects.toThrow(
        AuthenticationError,
      );
    });

    it("should include error message in thrown error", async () => {
      // Arrange
      const errorMessage = "인증 실패";
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "FAIL",
        resultMsg: errorMessage,
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).rejects.toThrow(errorMessage);
    });

    it("should handle unexpected response format", async () => {
      // Arrange
      const sessionInitResponse = {
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () => "<!DOCTYPE html>...",
        json: async () => ({}),
      } as unknown as HttpResponse;

      const invalidLoginResponse = {
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () => "Invalid JSON",
        json: async () => {
          throw new Error("Invalid JSON");
        },
      } as unknown as HttpResponse;

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(invalidLoginResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).rejects.toThrow(
        AuthenticationError,
      );
    });

    it("should handle non-200 HTTP status on login", async () => {
      // Arrange
      const sessionInitResponse = {
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () => "<!DOCTYPE html>...",
        json: async () => ({}),
      } as unknown as HttpResponse;

      const errorLoginResponse = {
        status: 500,
        statusText: "Internal Server Error",
        headers: new Headers(),
        text: async () => "Server Error",
        json: async () => ({}),
      } as unknown as HttpResponse;

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(errorLoginResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).rejects.toThrow(
        AuthenticationError,
      );
    });

    it("should handle non-200 HTTP status on session init", async () => {
      // Arrange
      const errorSessionInitResponse = {
        status: 500,
        statusText: "Internal Server Error",
        headers: new Headers(),
        text: async () => "Server Error",
        json: async () => ({}),
      } as unknown as HttpResponse;

      vi.mocked(mockHttpClient.fetch).mockResolvedValueOnce(errorSessionInitResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).rejects.toThrow(
        AuthenticationError,
      );
    });
  });

  /**
   * TEST-AUTH-003: Should use credentials from Secrets
   *
   * Criteria:
   * - USER_ID is read from env.USER_ID
   * - PASSWORD is read from env.PASSWORD
   * - No hardcoded credentials in code
   */
  describe("TEST-AUTH-003: Use credentials from Secrets", () => {
    it("should use USER_ID from environment", async () => {
      // Arrange
      const testUserId = "my-test-user";
      mockEnv.USER_ID = testUserId;

      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const requestBody = loginCall[1]?.body as string;

      expect(requestBody).toContain(testUserId);
    });

    it("should use PASSWORD from environment", async () => {
      // Arrange
      const testPassword = "secret-password-123";
      mockEnv.PASSWORD = testPassword;

      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const requestBody = loginCall[1]?.body as string;

      expect(requestBody).toContain(testPassword);
    });

    it("should work with different credentials", async () => {
      // Arrange
      mockEnv.USER_ID = "another-user";
      mockEnv.PASSWORD = "another-pass";

      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act & Assert
      await expect(login(mockHttpClient, mockEnv)).resolves.not.toThrow();
    });
  });

  /**
   * TEST-AUTH-004: Should send proper login request format
   *
   * Criteria:
   * - Content-Type is application/x-www-form-urlencoded
   * - Request method is POST
   * - Required form fields are included
   */
  describe("TEST-AUTH-004: Send proper login request format", () => {
    it("should send POST request with correct Content-Type", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];

      expect(loginCall[1]?.method).toBe("POST");
      expect(loginCall[1]?.headers?.["Content-Type"]).toBe(
        "application/x-www-form-urlencoded; charset=UTF-8",
      );
    });

    it("should include required browser-like headers", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const headers = loginCall[1]?.headers;

      expect(headers?.["User-Agent"]).toBeDefined();
      expect(headers?.["X-Requested-With"]).toBe("XMLHttpRequest");
      expect(headers?.["Referer"]).toBe("https://dhlottery.co.kr");
      expect(headers?.["Sec-Fetch-Site"]).toBe("same-site");
    });

    it("should include all required form parameters", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const requestBody = loginCall[1]?.body as string;

      // Should be URL-encoded form data with all required fields
      expect(requestBody).toContain("returnUrl=");
      expect(requestBody).toContain("userId=");
      expect(requestBody).toContain("password=");
      expect(requestBody).toContain("checkSave=off");
      expect(requestBody).toContain("newsEventYn=");
    });

    it("should properly URL-encode form data", async () => {
      // Arrange
      mockEnv.USER_ID = "test@email.com";
      mockEnv.PASSWORD = "p@ss w0rd!";

      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const requestBody = loginCall[1]?.body as string;

      // URLSearchParams encodes @ and ! but uses + for spaces (not %20)
      expect(requestBody).toContain("test%40email.com");
      expect(requestBody).toContain("p%40ss+w0rd%21");
    });

    it("should send request to correct endpoint", async () => {
      // Arrange
      const { sessionInitResponse, loginResponse, redirectResponse } = createMockResponses({
        resultCode: "SUCCESS",
      });

      vi.mocked(mockHttpClient.fetch)
        .mockResolvedValueOnce(sessionInitResponse)
        .mockResolvedValueOnce(loginResponse)
        .mockResolvedValueOnce(redirectResponse);

      // Act
      await login(mockHttpClient, mockEnv);

      // Assert - check second call (login request)
      const loginCall = vi.mocked(mockHttpClient.fetch).mock.calls[1];
      const url = loginCall[0];

      expect(url).toContain("dhlottery.co.kr");
      expect(url).toContain("/userSsl.do");
      expect(url).toContain("method=login");
    });
  });
});
