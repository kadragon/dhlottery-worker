spec_id: SPEC-REFACTOR-P1-ERROR-001
title: "Add PurchaseError class for purchase operations"
category: refactoring
phase: 1
priority: medium

given_when_then:
  - given: "AuthenticationError and NetworkError classes exist in src/utils/errors.ts"
    when: "purchase operations fail in buy.ts"
    then: "should throw PurchaseError with specific error codes instead of generic Error"

  - given: "PurchaseError follows the same pattern as AuthenticationError"
    when: "instantiated with message and optional code"
    then: "should have name='PurchaseError', inherit from DHLotteryError, and expose error code"

  - given: "purchase ready endpoint fails (line 39)"
    when: "preparePurchase() encounters HTTP error"
    then: "should throw PurchaseError with code 'PURCHASE_READY_FAILED'"

  - given: "purchase execution endpoint fails (line 91)"
    when: "executePurchase() encounters HTTP error"
    then: "should throw PurchaseError with code 'PURCHASE_EXECUTION_FAILED'"

acceptance_tests:
  - id: TEST-REFACTOR-P1-ERROR-001
    desc: "PurchaseError extends DHLotteryError"
    test: |
      new PurchaseError('test message', 'TEST_CODE') should be instanceof DHLotteryError

  - id: TEST-REFACTOR-P1-ERROR-002
    desc: "PurchaseError has correct name property"
    test: |
      new PurchaseError('test').name should equal 'PurchaseError'

  - id: TEST-REFACTOR-P1-ERROR-003
    desc: "PurchaseError accepts optional error code"
    test: |
      new PurchaseError('message', 'CUSTOM_CODE').code should equal 'CUSTOM_CODE'
      new PurchaseError('message').code should equal 'PURCHASE_ERROR' (default)

  - id: TEST-REFACTOR-P1-ERROR-004
    desc: "PurchaseError preserves message"
    test: |
      new PurchaseError('Test message').message should equal 'Test message'

rationale: |
  Current implementation uses generic Error class for purchase failures, making it
  difficult to distinguish purchase errors from other errors. Following the existing
  pattern (AuthenticationError, NetworkError), PurchaseError provides:
  - Consistent error handling across the codebase
  - Specific error codes for different failure scenarios
  - Better error categorization and debugging
  - Foundation for future error recovery strategies

impact:
  - Breaking change: No (new class, existing code unaffected until TASK-REFACTOR-P2-003)
  - Risk: Low (pure addition, no modifications to existing error classes)
  - Testing: Unit tests for PurchaseError class

files_affected:
  - src/utils/errors.ts (add PurchaseError class)

linked_tasks:
  - TASK-REFACTOR-P1-003
  - TASK-REFACTOR-P2-003 (will use PurchaseError in buy.ts)

dependencies:
  governance:
    - coding-style.md: "Follow existing error class patterns"
    - patterns.md: "Custom error classes for domain-specific failures"
